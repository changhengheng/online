<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>类型系统 | VitePress</title>
    <meta name="description" content="Just playing around.">
    <link rel="preload stylesheet" href="/assets/style.89c45cea.css" as="style">
    
    <script type="module" src="/assets/app.0c2984a5.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.2ed14f66.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/framework.419948d5.js">
    <link rel="modulepreload" href="/assets/chunks/theme.00fffdec.js">
    <link rel="modulepreload" href="/assets/program_frontend_TypeScript_summary_类型系统.md.6f75a188.lean.js">
    <script id="check-dark-light">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-1919c326><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0f60ec36></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0f60ec36> Skip to content </a><!--]--><!----><header class="VPNav" data-v-1919c326 data-v-7e5bc4a5><div class="VPNavBar" data-v-7e5bc4a5 data-v-a0fd61f4><div class="container" data-v-a0fd61f4><div class="title" data-v-a0fd61f4><div class="VPNavBarTitle" data-v-a0fd61f4 data-v-86d1bed8><a class="title" href="/" data-v-86d1bed8><!--[--><!--]--><!----><!--[-->VitePress<!--]--><!--[--><!--]--></a></div></div><div class="content" data-v-a0fd61f4><div class="curtain" data-v-a0fd61f4></div><div class="content-body" data-v-a0fd61f4><!--[--><!--]--><div class="VPNavBarSearch search" style="--vp-meta-key:&#39;Meta&#39;;" data-v-a0fd61f4><!----></div><nav aria-labelledby="main-nav-aria-label" class="VPNavBarMenu menu" data-v-a0fd61f4 data-v-7f418b0f><span id="main-nav-aria-label" class="visually-hidden" data-v-7f418b0f>Main Navigation</span><!--[--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/computerscience/" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>计算机科学</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/program/" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>编程</span><!--]--></a><!--]--><!--[--><a class="VPLink link VPNavBarMenuLink" href="/todolist/" tabindex="0" data-v-7f418b0f data-v-42ef59de><!--[--><span data-v-42ef59de>待办事项</span><!--]--></a><!--]--><!--]--></nav><!----><div class="VPNavBarAppearance appearance" data-v-a0fd61f4 data-v-f6a63727><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-f6a63727 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div><!----><div class="VPFlyout VPNavBarExtra extra" data-v-a0fd61f4 data-v-40855f84 data-v-9c007e85><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-9c007e85><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="icon" data-v-9c007e85><circle cx="12" cy="12" r="2"></circle><circle cx="19" cy="12" r="2"></circle><circle cx="5" cy="12" r="2"></circle></svg></button><div class="menu" data-v-9c007e85><div class="VPMenu" data-v-9c007e85 data-v-e7ea1737><!----><!--[--><!--[--><!----><div class="group" data-v-40855f84><div class="item appearance" data-v-40855f84><p class="label" data-v-40855f84>Appearance</p><div class="appearance-action" data-v-40855f84><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title="toggle dark mode" aria-checked="false" data-v-40855f84 data-v-ce54a7d1 data-v-b1685198><span class="check" data-v-b1685198><span class="icon" data-v-b1685198><!--[--><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="sun" data-v-ce54a7d1><path d="M12,18c-3.3,0-6-2.7-6-6s2.7-6,6-6s6,2.7,6,6S15.3,18,12,18zM12,8c-2.2,0-4,1.8-4,4c0,2.2,1.8,4,4,4c2.2,0,4-1.8,4-4C16,9.8,14.2,8,12,8z"></path><path d="M12,4c-0.6,0-1-0.4-1-1V1c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,3.6,12.6,4,12,4z"></path><path d="M12,24c-0.6,0-1-0.4-1-1v-2c0-0.6,0.4-1,1-1s1,0.4,1,1v2C13,23.6,12.6,24,12,24z"></path><path d="M5.6,6.6c-0.3,0-0.5-0.1-0.7-0.3L3.5,4.9c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C6.2,6.5,5.9,6.6,5.6,6.6z"></path><path d="M19.8,20.8c-0.3,0-0.5-0.1-0.7-0.3l-1.4-1.4c-0.4-0.4-0.4-1,0-1.4s1-0.4,1.4,0l1.4,1.4c0.4,0.4,0.4,1,0,1.4C20.3,20.7,20,20.8,19.8,20.8z"></path><path d="M3,13H1c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S3.6,13,3,13z"></path><path d="M23,13h-2c-0.6,0-1-0.4-1-1s0.4-1,1-1h2c0.6,0,1,0.4,1,1S23.6,13,23,13z"></path><path d="M4.2,20.8c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C4.7,20.7,4.5,20.8,4.2,20.8z"></path><path d="M18.4,6.6c-0.3,0-0.5-0.1-0.7-0.3c-0.4-0.4-0.4-1,0-1.4l1.4-1.4c0.4-0.4,1-0.4,1.4,0s0.4,1,0,1.4l-1.4,1.4C18.9,6.5,18.6,6.6,18.4,6.6z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewbox="0 0 24 24" class="moon" data-v-ce54a7d1><path d="M12.1,22c-0.3,0-0.6,0-0.9,0c-5.5-0.5-9.5-5.4-9-10.9c0.4-4.8,4.2-8.6,9-9c0.4,0,0.8,0.2,1,0.5c0.2,0.3,0.2,0.8-0.1,1.1c-2,2.7-1.4,6.4,1.3,8.4c2.1,1.6,5,1.6,7.1,0c0.3-0.2,0.7-0.3,1.1-0.1c0.3,0.2,0.5,0.6,0.5,1c-0.2,2.7-1.5,5.1-3.6,6.8C16.6,21.2,14.4,22,12.1,22zM9.3,4.4c-2.9,1-5,3.6-5.2,6.8c-0.4,4.4,2.8,8.3,7.2,8.7c2.1,0.2,4.2-0.4,5.8-1.8c1.1-0.9,1.9-2.1,2.4-3.4c-2.5,0.9-5.3,0.5-7.5-1.1C9.2,11.4,8.1,7.7,9.3,4.4z"></path></svg><!--]--></span></span></button></div></div></div><!----><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-a0fd61f4 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><!----></header><div class="VPLocalNav fixed reached-top" data-v-1919c326 data-v-79c8c1df><!----><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-79c8c1df data-v-1c15a60a><button data-v-1c15a60a>Return to top</button><!----></div></div><!----><div class="VPContent" id="VPContent" data-v-1919c326 data-v-669faec9><div class="VPDoc has-aside" data-v-669faec9 data-v-6b87e69f><!--[--><!--]--><div class="container" data-v-6b87e69f><div class="aside" data-v-6b87e69f><div class="aside-curtain" data-v-6b87e69f></div><div class="aside-container" data-v-6b87e69f><div class="aside-content" data-v-6b87e69f><div class="VPDocAside" data-v-6b87e69f data-v-3f215769><!--[--><!--]--><!--[--><!--]--><div class="VPDocAsideOutline" role="navigation" data-v-3f215769 data-v-6ae8e080><div class="content" data-v-6ae8e080><div class="outline-marker" data-v-6ae8e080></div><div class="outline-title" role="heading" data-v-6ae8e080>On this page</div><nav aria-labelledby="doc-outline-aria-label" data-v-6ae8e080><span class="visually-hidden" id="doc-outline-aria-label" data-v-6ae8e080> Table of Contents for current page </span><ul class="root" data-v-6ae8e080 data-v-d0ee3533><!--[--><!--]--></ul></nav></div></div><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-6b87e69f><div class="content-container" data-v-6b87e69f><!--[--><!--]--><!----><main class="main" data-v-6b87e69f><div style="position:relative;" class="vp-doc _program_frontend_TypeScript_summary_%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F" data-v-6b87e69f><div><h1 id="类型系统" tabindex="-1">类型系统 <a class="header-anchor" href="#类型系统" aria-label="Permalink to &quot;类型系统&quot;">​</a></h1><p>TypeScript 继承了 JavaScript 的类型，在这个基础上，定义了一套自己的类型系统。</p><p>JavaScript 语言（注意，不是 TypeScript）将值分成 8 种类型。</p><ul><li>boolean</li><li>string</li><li>number</li><li>bigint</li><li>symbol</li><li>object</li><li>undefined</li><li>null</li></ul><blockquote><p>注：除了数组、函数、对象，Map、Set 等也都归于对象这一大类，参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noreferrer">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures</a>, 更准确地说，Map 和 Set 不属于数据类型而属于数据结构。所以，JS 一共八种数据类型，其中 symbol 和 bigint 是 ES6 新增的。</p></blockquote><p>注意，上面所有类型的名称都是小写字母，首字母大写的 Number、String、Boolean 等在 JavaScript 语言中都是内置对象，而不是类型名称。</p><p>这 8 种基本类型是 TypeScript 类型系统的基础，复杂类型由它们组合而成。</p><h2 id="基本类型" tabindex="-1">基本类型 <a class="header-anchor" href="#基本类型" aria-label="Permalink to &quot;基本类型&quot;">​</a></h2><h3 id="boolean-类型" tabindex="-1">boolean 类型 <a class="header-anchor" href="#boolean-类型" aria-label="Permalink to &quot;boolean 类型&quot;">​</a></h3><p>boolean 类型只包含 true 和 false 两个布尔值。</p><h3 id="string-类型" tabindex="-1">string 类型 <a class="header-anchor" href="#string-类型" aria-label="Permalink to &quot;string 类型&quot;">​</a></h3><p>string 类型包含所有字符串。</p><h3 id="number-类型" tabindex="-1">number 类型 <a class="header-anchor" href="#number-类型" aria-label="Permalink to &quot;number 类型&quot;">​</a></h3><p>number 类型包含所有整数和浮点数。</p><blockquote><p>包括非十进制数</p></blockquote><h3 id="bigint-类型" tabindex="-1">bigint 类型 <a class="header-anchor" href="#bigint-类型" aria-label="Permalink to &quot;bigint 类型&quot;">​</a></h3><p>bigint 类型包含所有的大整数。</p><p>bigint 与 number 类型不兼容。</p><blockquote><p>表示大于 2^53 - 1 的整数</p></blockquote><p>注意，bigint 类型是 ES2020 标准引入的。如果使用这个类型，TypeScript 编译的目标 JavaScript 版本不能低于 ES2020（即编译参数 target 不低于 es2020）。</p><h3 id="symbol-类型" tabindex="-1">symbol 类型 <a class="header-anchor" href="#symbol-类型" aria-label="Permalink to &quot;symbol 类型&quot;">​</a></h3><p>symbol 类型包含所有的 Symbol 值。</p><h3 id="object-类型" tabindex="-1">object 类型 <a class="header-anchor" href="#object-类型" aria-label="Permalink to &quot;object 类型&quot;">​</a></h3><p>根据 JavaScript 的设计，object 类型包含了所有对象、数组和函数。</p><h3 id="undefined-类型-null-类型" tabindex="-1">undefined 类型，null 类型 <a class="header-anchor" href="#undefined-类型-null-类型" aria-label="Permalink to &quot;undefined 类型，null 类型&quot;">​</a></h3><p>undefined 和 null 是两种独立类型，它们各自都只有一个值。</p><p>undefined 类型只包含一个值 undefined，表示未定义（即还未给出定义，以后可能会有定义）。</p><p>null 类型也只包含一个值 null，表示为空（即此处没有值）。</p><p>注意，如果没有声明类型的变量，被赋值为 undefined 或 null，在关闭编译设置 noImplicitAny 和 strictNullChecks 时，它们的类型会被推断为 any。</p><p>如果希望避免这种情况，则需要打开编译选项 strictNullChecks。</p><h2 id="包装对象类型" tabindex="-1">包装对象类型 <a class="header-anchor" href="#包装对象类型" aria-label="Permalink to &quot;包装对象类型&quot;">​</a></h2><h3 id="包装对象的概念" tabindex="-1">包装对象的概念 <a class="header-anchor" href="#包装对象的概念" aria-label="Permalink to &quot;包装对象的概念&quot;">​</a></h3><p>JavaScript 的 8 种类型之中，undefined 和 null 其实是两个特殊值，object 属于复合类型，剩下的五种属于原始类型（primitive value），代表最基本的、不可再分的值。</p><ul><li>boolean</li><li>string</li><li>number</li><li>bigint</li><li>symbol</li></ul><p>上面这五种原始类型的值，都有对应的包装对象（wrapper object）。所谓“包装对象”，指的是这些值在需要时，会自动产生的对象。</p><p>五种包装对象之中，symbol 类型和 bigint 类型无法直接获取它们的包装对象（即 Symbol()和 BigInt()不能作为构造函数使用），但是剩下三种可以。</p><ul><li>Boolean()</li><li>String()</li><li>Number()</li></ul><p>以上三个构造函数，执行后可以直接获取某个原始类型值的包装对象。</p><p>注意，String()只有当作构造函数使用时（即带有 new 命令调用），才会返回包装对象。如果当作普通函数使用（不带有 new 命令），返回就是一个普通字符串。其他两个构造函数 Number()和 Boolean()也是如此。</p><blockquote><p>包装对象 typeof 检测返回 object，但它们本质上还是各自的类型，可以使用各自类型的方法。</p></blockquote><h3 id="包装对象类型与字面量类型" tabindex="-1">包装对象类型与字面量类型 <a class="header-anchor" href="#包装对象类型与字面量类型" aria-label="Permalink to &quot;包装对象类型与字面量类型&quot;">​</a></h3><p>由于包装对象的存在，导致每一个原始类型的值都有包装对象和字面量两种情况。</p><p>为了区分这两种情况，TypeScript 对五种原始类型分别提供了大写和小写两种类型。</p><ul><li>Boolean 和 boolean</li><li>String 和 string</li><li>Number 和 number</li><li>BigInt 和 bigint</li><li>Symbol 和 symbol</li></ul><p>其中，大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。</p><p>即，大写类型可以赋值为字面量，也可以赋值为包装对象。但是，小写类型只能赋值为字面量，赋值为包装对象就会报错。</p><p>建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象。而且，TypeScript 把很多内置方法的参数，定义成小写类型，使用大写类型会报错。</p><p>Symbol()和 BigInt()这两个函数不能当作构造函数使用，所以没有办法直接获得 symbol 类型和 bigint 类型的包装对象，除非使用下面的写法。但是，它们没有使用场景，因此 Symbol 和 BigInt 这两个类型虽然存在，但是完全没有使用的理由。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">Symbol</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Object</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">BigInt</span><span style="color:#E1E4E8;">());</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">Symbol</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Object</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">BigInt</span><span style="color:#24292E;">());</span></span></code></pre></div><p>上面示例中，得到的就是 Symbol 和 BigInt 的包装对象，但是没有使用的意义。</p><p>注意，目前在 TypeScript 里面，symbol 和 Symbol 两种写法没有差异，bigint 和 BigInt 也是如此，不知道是否属于官方的疏忽。建议始终使用小写的 symbol 和 bigint，不使用大写的 Symbol 和 BigInt。</p><h2 id="object-类型与-object-类型" tabindex="-1">Object 类型与 object 类型 <a class="header-anchor" href="#object-类型与-object-类型" aria-label="Permalink to &quot;Object 类型与 object 类型&quot;">​</a></h2><p>TypeScript 的对象类型也有大写 Object 和小写 object 两种。</p><h3 id="object-类型-1" tabindex="-1">Object 类型 <a class="header-anchor" href="#object-类型-1" aria-label="Permalink to &quot;Object 类型&quot;">​</a></h3><p>大写的 Object 类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是 Object 类型，这囊括了几乎所有的值。</p><p>原始类型值、对象、数组、函数都是合法的 Object 类型。</p><p>事实上，除了 undefined 和 null 这两个值不能转为对象，其他任何值都可以赋值给 Object 类型。</p><p>另外，空对象{}是 Object 类型的简写形式，所以使用 Object 时常常用空对象代替。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> obj</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> {};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> obj</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> {};</span></span></code></pre></div><p>显然，无所不包的 Object 类型既不符合直觉，也不方便使用。</p><h3 id="object-类型-2" tabindex="-1">object 类型 <a class="header-anchor" href="#object-类型-2" aria-label="Permalink to &quot;object 类型&quot;">​</a></h3><p>小写的 object 类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。</p><p>大多数时候，我们使用对象类型，只希望包含真正的对象，不希望包含原始类型。所以，建议总是使用小写类型 object，不使用大写类型 Object。</p><p>注意，无论是大写的 Object 类型，还是小写的 object 类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中。</p><h2 id="undefined-和-null-的特殊性" tabindex="-1">undefined 和 null 的特殊性 <a class="header-anchor" href="#undefined-和-null-的特殊性" aria-label="Permalink to &quot;undefined 和 null 的特殊性&quot;">​</a></h2><p>undefined 和 null 既是值，又是类型。</p><p>作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为 undefined 或 null。</p><p>这并不是因为 undefined 和 null 包含在 number 类型里面，而是故意这样设计，任何类型的变量都可以赋值为 undefined 和 null，以便跟 JavaScript 的行为保持一致。</p><p>JavaScript 的行为是，变量如果等于 undefined 就表示还没有赋值，如果等于 null 就表示值为空。所以，TypeScript 就允许了任何类型的变量都可以赋值为这两个值。</p><p>TypeScript 提供了一个编译选项 strictNullChecks。只要打开这个选项，undefined 和 null 就不能赋值给其他类型的变量（除了 any 类型和 unknown 类型）。</p><p>这个选项在配置文件 tsconfig.json 的写法如下。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#9ECBFF;">&quot;compilerOptions&quot;</span><span style="color:#E1E4E8;">: {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#9ECBFF;">&quot;strictNullChecks&quot;</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">true</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#032F62;">&quot;compilerOptions&quot;</span><span style="color:#24292E;">: {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#032F62;">&quot;strictNullChecks&quot;</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">true</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#6A737D;">// ...</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>打开 strictNullChecks 以后，undefined 和 null 这两种值也不能互相赋值了。打开 strictNullChecks 以后，undefined 和 null 只能赋值给自身，或者 any 类型和 unknown 类型的变量。</p><h2 id="值类型" tabindex="-1">值类型 <a class="header-anchor" href="#值类型" aria-label="Permalink to &quot;值类型&quot;">​</a></h2><p>TypeScript 规定，单个值也是一种类型，称为“值类型”。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 正确</span></span>
<span class="line"><span style="color:#E1E4E8;">x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;world&quot;</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 报错</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 正确</span></span>
<span class="line"><span style="color:#24292E;">x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;world&quot;</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 报错</span></span></code></pre></div><p>上面示例中，变量 x 的类型是字符串 hello，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。</p><p>TypeScript 推断类型时，遇到 const 命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。</p><p>这样推断是合理的，因为 const 命令声明的变量，一旦声明就不能改变，相当于常量。值类型就意味着不能赋为其他值。</p><p>注意，const 命令声明的变量，如果赋值为对象，并不会推断为值类型。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// x 的类型是 { foo: number }</span></span>
<span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">x</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> };</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// x 的类型是 { foo: number }</span></span>
<span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">x</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { foo: </span><span style="color:#005CC5;">1</span><span style="color:#24292E;"> };</span></span></code></pre></div><p>上面示例中，变量 x 没有被推断为值类型，而是推断属性 foo 的类型是 number。这是因为 JavaScript 里面，const 变量赋值为对象时，属性值是可以改变的。</p><p>值类型可能会出现一些很奇怪的报错。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 报错</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 报错</span></span></code></pre></div><p>上面示例中，等号左侧的类型是数值 5，等号右侧 4 + 1 的类型，TypeScript 推测为 number。由于 5 是 number 的子类型，number 是 5 的父类型，父类型不能赋值给子类型，所以报错了（详见本章后文）。</p><p>但是，反过来是可以的，子类型可以赋值给父类型。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> y</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">x </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> y; </span><span style="color:#6A737D;">// 报错</span></span>
<span class="line"><span style="color:#E1E4E8;">y </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> x; </span><span style="color:#6A737D;">// 正确</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> y</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">x </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> y; </span><span style="color:#6A737D;">// 报错</span></span>
<span class="line"><span style="color:#24292E;">y </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> x; </span><span style="color:#6A737D;">// 正确</span></span></code></pre></div><p>上面示例中，变量 x 属于子类型，变量 y 属于父类型。子类型 x 不能赋值为父类型 y，但是反过来是可以的。</p><p>如果一定要让子类型可以赋值为父类型的值，就要用到类型断言（详见《类型断言》一章）。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">as</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">5</span><span style="color:#E1E4E8;">; </span><span style="color:#6A737D;">// 正确</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">4</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">as</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">5</span><span style="color:#24292E;">; </span><span style="color:#6A737D;">// 正确</span></span></code></pre></div><p>上面示例中，在 4 + 1 后面加上 as 5，就是告诉编译器，可以把 4 + 1 的类型视为值类型 5，这样就不会报错了。</p><p>只包含单个值的值类型，用处不大。实际开发中，往往将多个值结合，作为联合类型使用。</p><h2 id="联合类型" tabindex="-1">联合类型 <a class="header-anchor" href="#联合类型" aria-label="Permalink to &quot;联合类型&quot;">​</a></h2><p>联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。</p><p>联合类型 A|B 表示，任何一个类型只要属于 A 或 B，就属于联合类型 A|B。</p><p>联合类型可以与值类型相结合，表示一个变量的值有若干种可能。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> rainbowColor</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;赤&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;橙&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;黄&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;绿&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;青&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;蓝&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;紫&quot;</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> rainbowColor</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;赤&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;橙&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;黄&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;绿&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;青&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;蓝&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;紫&quot;</span><span style="color:#24292E;">;</span></span></code></pre></div><p>前面提到，打开编译选项 strictNullChecks 后，其他类型的变量不能赋值为 undefined 或 null。这时，如果某个变量确实可能包含空值，就可以采用联合类型的写法。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> name</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> name</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span><span style="color:#24292E;">;</span></span></code></pre></div><blockquote><p>这样写不会报错</p></blockquote><p>联合类型的第一个成员前面，也可以加上竖杠|，这样便于多行书写。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">let x:</span></span>
<span class="line"><span style="color:#e1e4e8;">  | &#39;one&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">  | &#39;two&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">  | &#39;three&#39;</span></span>
<span class="line"><span style="color:#e1e4e8;">  | &#39;four&#39;;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">let x:</span></span>
<span class="line"><span style="color:#24292e;">  | &#39;one&#39;</span></span>
<span class="line"><span style="color:#24292e;">  | &#39;two&#39;</span></span>
<span class="line"><span style="color:#24292e;">  | &#39;three&#39;</span></span>
<span class="line"><span style="color:#24292e;">  | &#39;four&#39;;</span></span></code></pre></div><p>如果一个变量有多种类型，读取该变量时，往往需要进行“类型缩小”（type narrowing），区分该值到底属于哪一种类型，然后再进一步处理。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">printId</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">id</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">|</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> id </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;string&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(id.</span><span style="color:#B392F0;">toUpperCase</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">  } </span><span style="color:#F97583;">else</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(id);</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">printId</span><span style="color:#24292E;">(</span><span style="color:#E36209;">id</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">|</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> id </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;string&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(id.</span><span style="color:#6F42C1;">toUpperCase</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">  } </span><span style="color:#D73A49;">else</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(id);</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。实际上，联合类型本身可以看成是一种“类型放大”（type widening），处理时就需要“类型缩小”（type narrowing）</p><h2 id="交叉类型" tabindex="-1">交叉类型 <a class="header-anchor" href="#交叉类型" aria-label="Permalink to &quot;交叉类型&quot;">​</a></h2><p>交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号&amp;表示。</p><p>交叉类型 A&amp;B 表示，任何一个类型必须同时属于 A 和 B，才属于交叉类型 A&amp;B，即交叉类型同时满足 A 和 B 的特征。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> x</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> x</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;">;</span></span></code></pre></div><p>上面示例中，变量 x 同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为 x 的类型实际是 never。</p><p>交叉类型的主要用途是表示对象的合成。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> obj</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> { </span><span style="color:#FFAB70;">foo</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;"> } </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> { </span><span style="color:#FFAB70;">bar</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">string</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">obj </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#9ECBFF;">&quot;hello&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">  bar: </span><span style="color:#9ECBFF;">&quot;world&quot;</span><span style="color:#E1E4E8;">,</span></span>
<span class="line"><span style="color:#E1E4E8;">};</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> obj</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> { </span><span style="color:#E36209;">foo</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;"> } </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> { </span><span style="color:#E36209;">bar</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">string</span><span style="color:#24292E;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">obj </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">  foo: </span><span style="color:#032F62;">&quot;hello&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">  bar: </span><span style="color:#032F62;">&quot;world&quot;</span><span style="color:#24292E;">,</span></span>
<span class="line"><span style="color:#24292E;">};</span></span></code></pre></div><p>上面示例中，变量 obj 同时具有属性 foo 和属性 bar。</p><p>交叉类型常常用来为对象类型添加新属性。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { </span><span style="color:#FFAB70;">foo</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">B</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">A</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">&amp;</span><span style="color:#E1E4E8;"> { </span><span style="color:#FFAB70;">bar</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;"> };</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> { </span><span style="color:#E36209;">foo</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> };</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">B</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">A</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">&amp;</span><span style="color:#24292E;"> { </span><span style="color:#E36209;">bar</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;"> };</span></span></code></pre></div><p>上面示例中，类型 B 是一个交叉类型，用来在 A 的基础上增加了属性 bar。</p><h2 id="type-命令" tabindex="-1">type 命令 <a class="header-anchor" href="#type-命令" aria-label="Permalink to &quot;type 命令&quot;">​</a></h2><p>type 命令用来定义一个类型的别名。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Age</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">number</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> age</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Age</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">55</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Age</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">number</span><span style="color:#24292E;">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> age</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Age</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">55</span><span style="color:#24292E;">;</span></span></code></pre></div><p>上面示例中，type 命令为 number 类型定义了一个别名 Age。这样就能像使用 number 一样，使用 Age 作为类型。</p><p>别名可以让类型的名字变得更有意义，也能增加代码的可读性，还可以使复杂类型用起来更方便，便于以后修改变量的类型。</p><p>别名不允许重名。</p><p>别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。</p><p>别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">World</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;world&quot;</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">type</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Greeting</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">`hello ${</span><span style="color:#B392F0;">World</span><span style="color:#9ECBFF;">}`</span><span style="color:#E1E4E8;">;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">World</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;world&quot;</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">type</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Greeting</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#032F62;">`hello ${</span><span style="color:#6F42C1;">World</span><span style="color:#032F62;">}`</span><span style="color:#24292E;">;</span></span></code></pre></div><p>上面示例中，别名 Greeting 使用了模板字符串，读取另一个别名 World。</p><p>type 命令属于类型相关的代码，编译成 JavaScript 的时候，会被全部删除。</p><h2 id="typeof-运算符" tabindex="-1">typeof 运算符 <a class="header-anchor" href="#typeof-运算符" aria-label="Permalink to &quot;typeof 运算符&quot;">​</a></h2><p>TypeScript 将 typeof 运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。</p><p>这种用法的 typeof 返回的是 TypeScript 类型，所以只能用在类型运算之中（即跟类型相关的代码之中），不能用在值运算。</p><p>也就是说，同一段代码可能存在两种 typeof 运算符，一种用在值相关的 JavaScript 代码部分，另一种用在类型相关的 TypeScript 代码部分。</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">;</span></span>
<span class="line"><span style="color:#F97583;">let</span><span style="color:#E1E4E8;"> b</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> a </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;number&quot;</span><span style="color:#E1E4E8;">) {</span></span>
<span class="line"><span style="color:#E1E4E8;">  b </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> a;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span><span style="color:#24292E;">;</span></span>
<span class="line"><span style="color:#D73A49;">let</span><span style="color:#24292E;"> b</span><span style="color:#D73A49;">:</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> a;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> a </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;number&quot;</span><span style="color:#24292E;">) {</span></span>
<span class="line"><span style="color:#24292E;">  b </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> a;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>上面示例中，用到了两个 typeof，第一个是类型运算，第二个是值运算。它们是不一样的，不要混淆。</p><p>JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。</p><p>由于编译时不会进行 JavaScript 的值运算，所以 TypeScript 规定，typeof 的参数只能是标识符，不能是需要运算的表达式。</p><p>另外，typeof 命令的参数不能是类型。</p><h2 id="块级类型声明" tabindex="-1">块级类型声明 <a class="header-anchor" href="#块级类型声明" aria-label="Permalink to &quot;块级类型声明&quot;">​</a></h2><p>TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。</p><h2 id="类型的兼容" tabindex="-1">类型的兼容 <a class="header-anchor" href="#类型的兼容" aria-label="Permalink to &quot;类型的兼容&quot;">​</a></h2><p>TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。</p><blockquote><p>联合类型兼容任何在联合类型内的类型</p></blockquote><p>TypeScript 为这种情况定义了一个专门术语。如果类型 A 的值可以赋值给类型 B，那么类型 A 就称为类型 B 的子类型（subtype）。在上例中，类型 number 就是类型 number|string 的子类型。</p><p>TypeScript 的一个规则是，凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行。</p><p>之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。</p></div></div></main><footer class="VPDocFooter" data-v-6b87e69f data-v-ef5dee53><!--[--><!--]--><div class="edit-info" data-v-ef5dee53><!----><div class="last-updated" data-v-ef5dee53><p class="VPLastUpdated" data-v-ef5dee53 data-v-7de715c0>Last updated: <time datetime="2023-09-13T10:04:41.000Z" data-v-7de715c0></time></p></div></div><!----></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"program_businesslogic_1.刚入职的新人如何快速了解公司业务.md\":\"204be6e2\",\"program_frontend_git_index.md\":\"6ad51483\",\"program_frontend_node_chapter1_36.请求体.md\":\"e5c11aa1\",\"program_frontend_node_chapter1_53.网页资源加载基本过程.md\":\"63c426b1\",\"program_frontend_codelogic_自定义属性.md\":\"d658dec8\",\"program_frontend_codelogic_权限管理.md\":\"0efa5d24\",\"program_base_bs架构_bs架构和cs架构.md\":\"96698630\",\"program_frontend_node_chapter1_44.浏览器查看http报文.md\":\"43e486e4\",\"program_base_bs架构_bs架构客户端和服务器的交互过程.md\":\"0c021afc\",\"program_frontend_node_chapter1_41.端口.md\":\"f30fddfc\",\"program_frontend_javascript_滚轮事件.md\":\"003376e7\",\"program_frontend_node_chapter1_43.http服务注意事项.md\":\"c26ef9ca\",\"program_frontend_node_chapter1_6.命令行工具.md\":\"29a3b8b6\",\"program_frontend_codelogic_大屏可视化.md\":\"2d41b69a\",\"program_frontend_lodash_index.md\":\"e37b324e\",\"program_frontend_node_chapter1_24.删除文件.md\":\"ad651bd0\",\"program_frontend_node_chapter1_11.计算机基本组成.md\":\"d058009c\",\"program_frontend_vue_vue3_base_officialdocument_在vue中使用ts.md\":\"25906263\",\"program_frontend_lodash_lodashchain的显式链和隐式链.md\":\"965eb382\",\"navigation_index.md\":\"ef8b41b3\",\"program_frontend_node_index.md\":\"9d8214b4\",\"program_frontend_vue_index.md\":\"fb465479\",\"program_base_善用github搜索技巧，找到合适的项目进行练习.md\":\"18e48f39\",\"program_frontend_vue_vue3_1.组合api_11.封装发送ajax请求的hook函数.md\":\"48b96265\",\"program_backend_mysql_base_chapter1_untitled.md\":\"5dbe4a8f\",\"program_frontend_vue_vue3_1.组合api_7.reactive和ref细节.md\":\"ecec4f69\",\"program_frontend_javascript_参考文档备份_让页面滑动流畅得飞起的新特性：passive event listeners_让页面滑动流畅得飞起的新特性：passive event listeners.md\":\"04a4d32d\",\"program_frontend_node_chapter5_17.mongodb图形化管理工具.md\":\"e97250ca\",\"program_frontend_vue_vue3_base_officialdocument_进阶主题_渲染机制.md\":\"ed387ec8\",\"program_backend_inlux_常用命令.md\":\"0436fc14\",\"program_frontend_javascript_触摸事件.md\":\"64018492\",\"program_frontend_vue_vue3_2.新组件_1.fragment.md\":\"a1e2a149\",\"program_frontend_node_chapter1_2.为什么要学习nodejs.md\":\"4bd26e7e\",\"program_frontend_node_chapter1_21.文件流式读取.md\":\"a21177c4\",\"program_frontend_commonsense_index.md\":\"06271256\",\"program_frontend_node_chapter1_12.程序运行的基本流程.md\":\"224872d4\",\"program_frontend_node_chapter5_11.mongoose更新文档.md\":\"6869906d\",\"program_frontend_node_chapter1_55.静态资源和动态资源.md\":\"76eb4fd2\",\"program_frontend_node_chapter1_3.nodejs是什么.md\":\"665aa8a1\",\"program_frontend_node_base_前台路由和后台路由.md\":\"22094614\",\"program_frontend_node_chapter1_68.commonjs模块化规范.md\":\"1f10f20b\",\"program_frontend_node_chapter3_4.获取请求报文参数.md\":\"016cfeba\",\"program_frontend_node_chapter1_34.请求报文结构.md\":\"f9555a33\",\"暂存_新建文件夹_ssh和http的异同.md\":\"00f93885\",\"program_frontend_vue_vue3_base_officialdocument_base_1.创建应用.md\":\"7d0a4e73\",\"program_frontend_webpack_chapter1_14.处理字体图标资源.md\":\"95b565a6\",\"program_frontend_node_chapter3_8.其他响应方法.md\":\"8e812ac6\",\"program_frontend_typescript_base_0.介绍.md\":\"48ee2d26\",\"program_frontend_webpack_chapter1_11.处理图片资源.md\":\"add0b44d\",\"program_frontend_node_chapter3_9.中间件.md\":\"01bf5114\",\"program_frontend_node_chapter5_13.mongoose条件控制.md\":\"3dfe2c50\",\"program_frontend_node_chapter1_52.http练习.md\":\"97c81f0a\",\"program_frontend_node_chapter3_17.防盗链练习.md\":\"c4c0036a\",\"program_frontend_node_chapter1_19.文件读取.md\":\"e675b944\",\"program_frontend_vue_vue3_1.组合api_16.toraw和markraw.md\":\"a71ce153\",\"program_frontend_node_chapter3_20.ejs.md\":\"8d273a9d\",\"program_frontend_vue_vue3_base_officialdocument_base_index.md\":\"4310f910\",\"program_frontend_node_chapter1_10.buffer操作与注意点.md\":\"0f1c7c3e\",\"program_frontend_vue_vue3_1.组合api_8.computed和watch.md\":\"5cdf3d29\",\"program_frontend_codesnippet_判断两次点击的是否是同一个元素.md\":\"a65d0db8\",\"program_frontend_codelogic_登陆注册.md\":\"3e85d9c9\",\"program_frontend_node_chapter4_练习3_获取表单数据.md\":\"7b4e85e5\",\"program_frontend_node_chapter1_30.path模块.md\":\"04c083c0\",\"program_frontend_webpack_chapter1_2.为什么需要使用webpack.md\":\"beca9313\",\"program_base_bs架构_静态网站和动态网站.md\":\"57081ffa\",\"program_frontend_javascript_函数表达式.md\":\"55afcc6c\",\"program_frontend_vue_vue3_base_index.md\":\"ac66e76d\",\"computerscience_index.md\":\"7ae15c7d\",\"program_frontend_vue_vue3_4.补充_1.类型约束.md\":\"90add6c4\",\"暂存_新建文件夹 (2)_git statsh和gitcommit解决冲突.md\":\"30ea1489\",\"program_frontend_typescript_index.md\":\"ba749799\",\"暂存_nginx_前置知识_互联网.md\":\"5b8f2171\",\"program_frontend_node_chapter1_54.网页引入外部资源练习.md\":\"856c8a85\",\"program_backend_inlux_介绍.md\":\"b025a301\",\"program_frontend_webpack_chapter1_29.总结.md\":\"963aff46\",\"program_frontend_node_chapter3_26.处理文件上传类型的请求报文.md\":\"09b7456f\",\"program_frontend_node_chapter1_59.设置资源mime类型.md\":\"9b66f566\",\"program_frontend_codelogic_处理并发.md\":\"f76b7186\",\"program_frontend_node_chapter5_9.mongoose字段值验证.md\":\"78688090\",\"program_frontend_node_chapter1_27.fs模块路径问题.md\":\"a855cbf2\",\"program_base_bs架构_常识.md\":\"101b06cd\",\"program_frontend_typescript_chapter1_2.类型推断.md\":\"957c2ef7\",\"program_frontend_node_base_目录的概念.md\":\"07c9e3a1\",\"program_backend_inlux_index.md\":\"083be651\",\"program_frontend_vue_vue3_小结.md\":\"a503d5fb\",\"program_frontend_node_chapter3_22.ejs条件渲染.md\":\"9929de66\",\"program_frontend_node_chapter5_2.mongodb核心概念.md\":\"f498e11d\",\"thinkandrecord_utils_怎么样让自己好过一点.md\":\"4eb9d857\",\"program_frontend_vue_vue3_4.补充_自定义事件的用法.md\":\"8858c8e2\",\"program_frontend_nest_index.md\":\"13589562\",\"program_frontend_node_chapter1_38.响应头和响应体.md\":\"1d522efa\",\"program_frontend_vue_vue3_1.组合api_6.setup深入.md\":\"e14bc2df\",\"english_word_index.md\":\"6aba5bae\",\"暂存_archieves_readme.md\":\"3c9bfa98\",\"program_frontend_webpack_chapter1_3.webpack介绍_基本使用.md\":\"dbdf662e\",\"program_frontend_node_chapter5_6.mongoose连接数据库.md\":\"1a3cbc5a\",\"program_frontend_javascript_键盘事件.md\":\"138ce46f\",\"program_businesslogic_index.md\":\"84320041\",\"program_backend_mysql_index.md\":\"70384456\",\"program_frontend_webpack_chapter1_15.处理其他资源.md\":\"0a5d9e65\",\"program_frontend_node_chapter5_12.mongoose读取文档.md\":\"882a5775\",\"program_frontend_webpack_chapter1_4.webpack5大核心概念.md\":\"b78e0161\",\"program_frontend_webpack_chapter2_34.includeexclude提升打包构建速度.md\":\"f826b881\",\"program_frontend_webpack_chapter2_38.减少babel生成文件的体积.md\":\"1122107e\",\"program_frontend_node_chapter1_56.搭建静态资源服务.md\":\"7b95ed27\",\"program_frontend_vue_vue3_4.补充_插槽的用法.md\":\"cd1c6212\",\"program_backend_inlux_linux 系统目录结构.md\":\"9496bd7a\",\"program_frontend_node_chapter3_6.路由参数练习.md\":\"e5db278c\",\"program_frontend_vue_vue3_base_officialdocument_介绍.md\":\"86a8c4ed\",\"program_frontend_mockjs_语法规范.md\":\"e8b1cfe3\",\"program_frontend_webpack_chapter1_26.封住样式loader函数.md\":\"88be8798\",\"program_frontend_webpack_chapter2_43.codesplit统一命名.md\":\"c02afbe7\",\"program_frontend_node_chapter3_3.路由.md\":\"1985c97a\",\"program_frontend_node_chapter5_15.mongoose代码模块化.md\":\"b799d1a6\",\"program_frontend_vue_vue3_readme.md\":\"291d30ec\",\"program_frontend_typescript_summary_类型系统.md\":\"6f75a188\",\"program_frontend_webpack_chapter2_36.多进程打包提升打包构建速度.md\":\"3f78d94b\",\"program_frontend_package_js-cookie.md\":\"7d782a68\",\"program_frontend_node_chapter1_62.get请求和post请求的应用场景与区别.md\":\"79d393be\",\"program_frontend_typescript_summary_元组.md\":\"a285641b\",\"program_frontend_vue_vue3_base_officialdocument_base_4.计算属性.md\":\"2508dbec\",\"program_frontend_node_chapter3_18.路由模块化.md\":\"8d11fae4\",\"english_index.md\":\"91ce4ad5\",\"program_frontend_mockjs_api.md\":\"75ddee18\",\"program_frontend_webpack_chapter1_16.处理js资源.md\":\"c0f875cb\",\"program_frontend_codelogic_鉴权.md\":\"1b866b6a\",\"program_frontend_vue_vue3_1.组合api_2.setup和ref的基本使用.md\":\"9ad96b6d\",\"program_frontend_node_chapter3_index.md\":\"a7a3c195\",\"index.md\":\"83b96660\",\"program_frontend_vue_vue3_0.起步_4.vue3的devtools.md\":\"33605e02\",\"program_frontend_uniapp_apk打包流程.md\":\"8fb22208\",\"program_frontend_javascript_改善移动端设备的滚屏性能.md\":\"a120a0a2\",\"program_frontend_node_chapter1_7.nodejs初体验.md\":\"26362086\",\"program_frontend_node_chapter1_32.初识http协议.md\":\"f9573add\",\"program_frontend_node_chapter1_37.响应报文结构.md\":\"f26bb4ac\",\"program_frontend_node_chapter1_66.引入模块数据.md\":\"98947dc0\",\"program_frontend_vue_vue3_base_officialdocument_副作用和纯函数.md\":\"ed18b32f\",\"program_frontend_node_chapter3_1.express介绍.md\":\"13dd845a\",\"program_backend_java_index.md\":\"5f30dcfd\",\"program_frontend_node_chapter1_9.buffer.md\":\"2bae292d\",\"program_frontend_vue_vue3_2.新组件_2.teleport.md\":\"0e46a966\",\"program_frontend_typescript_summary_数组.md\":\"6d99a6c6\",\"program_frontend_vue_vue3_1.组合api_12.torefs.md\":\"59e8110c\",\"program_frontend_node_chapter3_16.防盗链介绍.md\":\"420c7091\",\"program_frontend_nuxt_index.md\":\"cb7f7006\",\"program_frontend_webpack_chapter1_28.html和js压缩介绍.md\":\"32b9d487\",\"program_businesslogic_2.加入新公司，怎样快速熟悉业务和项目.md\":\"c9c19355\",\"program_frontend_webpack_chapter1_5.webpack基础配置.md\":\"33075416\",\"program_frontend_uniapp_index.md\":\"4fc5d5a3\",\"program_frontend_vue_vue3_base_officialdocument_进阶主题_渲染函数_jsx.md\":\"2fb6a68a\",\"program_frontend_javascript_index.md\":\"e3abb7b1\",\"thinkandrecord_work_商业场基本逻辑.md\":\"5cdf7405\",\"program_frontend_codesnippet_index.md\":\"ee688ddf\",\"program_frontend_vue_vue3_1.组合api_5.vue2和vue3响应式的对比.md\":\"29bdd3cb\",\"program_frontend_node_chapter3_12.静态资源中间件.md\":\"f0ee9c8d\",\"program_frontend_node_chapter3_14.静态资源中间件练习.md\":\"9dcfeded\",\"program_frontend_node_chapter4_练习4_lowdb.md\":\"87491f97\",\"program_frontend_node_chapter1_35.请求头.md\":\"ec71a897\",\"program_frontend_vue_vue3_base_officialdocument_base_5.类与样式绑定.md\":\"815e246b\",\"program_frontend_node_chapter1_28.__dirname.md\":\"3690d19a\",\"program_frontend_codelogic_参考值思想.md\":\"be06bfda\",\"program_frontend_typescript_summary_index.md\":\"a95108e1\",\"program_frontend_webpack_chapter2_37.树摇减少代码体积.md\":\"261fe03f\",\"program_frontend_node_chapter1_57.静态资源目录和网站根目录.md\":\"4019889a\",\"program_frontend_webpack_chapter2_35.缓存eslint和babel提升打包构建速度.md\":\"38344708\",\"program_frontend_webpack_chapter1_9.处理sass和sass资源.md\":\"df247960\",\"program_frontend_webpack_base_index.md\":\"2b39b95a\",\"thinkandrecord_2023-09-05.md\":\"45c079eb\",\"program_frontend_vite_index.md\":\"13d18ce6\",\"program_backend_mysql_base_index.md\":\"15cd5991\",\"program_frontend_node_chapter5_index.md\":\"e3e6c7dd\",\"program_frontend_node_chapter1_39.ip.md\":\"c073912a\",\"program_frontend_node_chapter1_8.nodejs注意事项.md\":\"fee8808a\",\"program_frontend_webpack_chapter1_13.自动清空上次打包内容.md\":\"91be01ba\",\"thinkandrecord_utils_时间日志.md\":\"3d140f25\",\"program_frontend_webpack_chapter1_19.babel介绍.md\":\"94ba2433\",\"program_frontend_vue_vue3_0.起步_2.创建项目.md\":\"d7224eb5\",\"program_frontend_node_chapter3_21.ejs列表渲染.md\":\"0dbfa09d\",\"program_frontend_webpack_chapter2_44.preload和prefetch.md\":\"28395eed\",\"program_frontend_typescript_chapter1_1.类型声明.md\":\"5c6be78e\",\"program_interview_index.md\":\"22866bfc\",\"todolist_index.md\":\"e3be4944\",\"program_frontend_webpack_chapter2_47.pwa.md\":\"4a2bafb7\",\"program_frontend_node_chapter1_47.获取请求路径和查询字符串.md\":\"e7ee123e\",\"program_frontend_node_chapter1_16.fs模块之追加写入.md\":\"c53c72ca\",\"vitepress_index.md\":\"009d97e0\",\"program_frontend_vue_vue3_base_officialdocument_base_2.模板语法.md\":\"c8f17365\",\"program_frontend_webpack_chapter1_22.搭建开发服务器.md\":\"275f97d8\",\"program_frontend_node_chapter1_1.nodejs课程介绍.md\":\"45aa74ee\",\"program_frontend_node_chapter1_18.fs模块之文件写入应用场景.md\":\"5d5bdd1c\",\"program_frontend_node_chapter3_19.模板引擎.md\":\"b675f0e4\",\"program_frontend_vue_vue3_base_officialdocument_带setup属性的script标签.md\":\"38166512\",\"program_frontend_mockjs_index.md\":\"022733cf\",\"program_frontend_git_gitlab设置项目可见性.md\":\"f096e782\",\"program_frontend_node_chapter1_5.下载安装nodejs.md\":\"098dcbb6\",\"program_base_代码熟练度和工具函数.md\":\"4ab9745c\",\"program_backend_inlux_linux 远程登录.md\":\"38a0ec67\",\"program_frontend_node_chapter4_index.md\":\"9782c101\",\"program_frontend_node_chapter1_index.md\":\"299e30f7\",\"program_frontend_node_chapter1_17.fs模块之流式写入.md\":\"4b611f95\",\"program_frontend_webpack_chapter2_42.命名动态导入模块.md\":\"495e3746\",\"program_frontend_typescript_base_1.前置.md\":\"f825387c\",\"program_frontend_webpack_chapter1_17.eslint介绍.md\":\"e1ed705d\",\"program_frontend_codelogic_开关思想.md\":\"db907443\",\"program_frontend_webpack_chapter1_27.css压缩.md\":\"94f1366c\",\"program_frontend_webpack_chapter2_32.hmr提升打包构建速度.md\":\"14e51c02\",\"program_frontend_vue_vue3_base_officialdocument_base_6.条件渲染.md\":\"5c544453\",\"program_frontend_node_chapter5_3.下载安装与启动.md\":\"d0064b3d\",\"program_frontend_package_index.md\":\"143fa99a\",\"computerscience_computernetwork_index.md\":\"b4589317\",\"program_frontend_vue_vue3_0.起步_1.认识vue3.md\":\"01eb68a7\",\"program_frontend_node_base_转义字符.md\":\"f47dc2a5\",\"program_frontend_vue_vue3_1.组合api_20.判断响应式数据是怎样创建的.md\":\"9b485183\",\"program_frontend_codelogic_index.md\":\"d6986f49\",\"program_frontend_toolbox_index.md\":\"c19be5ac\",\"program_frontend_node_chapter1_14.fs模块之写入文件.md\":\"f9e1148a\",\"program_frontend_webpack_chapter2_31.sourcemap提升开发体验.md\":\"e719f4cd\",\"program_frontend_node_chapter1_64.模块化初体验.md\":\"d898a7e7\",\"program_frontend_webpack_chapter1_12.修改输出文件目录.md\":\"bb0c344a\",\"program_frontend_uniapp_h5打包流程.md\":\"9344d39c\",\"program_frontend_webpack_chapter1_1.前置.md\":\"adad59b6\",\"program_frontend_node_chapter1_33.查看http报文.md\":\"5d6badd2\",\"program_frontend_node_chapter3_2.express初体验.md\":\"863669a7\",\"program_frontend_webpack_chapter2_45.networkcache.md\":\"4be015fa\",\"program_frontend_vue_vue3_1.组合api_13.ref获取元素.md\":\"8b077737\",\"program_frontend_webpack_chapter1_8.处理less和less资源.md\":\"f8a695c0\",\"program_frontend_vue_vue3_1.组合api_19.provide和inject.md\":\"2a2fc870\",\"program_frontend_node_chapter5_14.mongoose数据个性化读取.md\":\"12c9dd4d\",\"program_frontend_node_chapter5_16.mongoose代码模块化.md\":\"b74ea9d4\",\"thinkandrecord_index.md\":\"6f36e858\",\"program_frontend_vue_vue3_1.组合api_14.shallowreactive和shallowref.md\":\"8d463ece\",\"program_base_项目部署.md\":\"4f36b7ca\",\"thinkandrecord_高速运转.md\":\"04f34a2c\",\"program_frontend_node_chapter3_11.路由中间件练习.md\":\"a0a40b00\",\"program_frontend_vue_vue3_0.起步_3.项目目录分析.md\":\"2e8f0e04\",\"program_index.md\":\"bb5c7806\",\"program_frontend_vue_vue3_base_officialdocument_进阶主题_index.md\":\"1452fabd\",\"program_frontend_node_chapter1_4.nodejs的作用.md\":\"b83b88e0\",\"program_frontend_node_chapter4_练习2_响应静态网页.md\":\"3cbf3dce\",\"program_frontend_vue_vue3_1.组合api_15.readonly和shallowreadonly.md\":\"71d10fd4\",\"program_frontend_node_chapter5_5.mongoose.md\":\"442f8ac6\",\"program_frontend_node_chapter1_20.文件读取应用场景.md\":\"4c27aca1\",\"program_frontend_node_chapter1_45.获取请求首行和请求头.md\":\"5013ff29\",\"program_frontend_node_chapter3_24.express-generator.md\":\"80f8fb23\",\"program_frontend_vue_vue3_base_officialdocument_base_7.列表渲染.md\":\"c35db50f\",\"program_base_bs架构_建立一个网站需要什么软件.md\":\"ebd4982c\",\"program_frontend_vue_vue3_1.组合api_17.toref.md\":\"b0827a8a\",\"program_frontend_node_chapter1_58.绝对路径和相对路径.md\":\"e6aefc7f\",\"暂存_怎么样才算是学会了.md\":\"db99d0b1\",\"program_frontend_index.md\":\"1df15b5e\",\"program_frontend_typescript_base_2.tsconfig.json.md\":\"cf7fdba8\",\"thinkandrecord_消费降级.md\":\"0ba8098e\",\"program_frontend_node_chapter1_67.require导入自定义模块的基本流程.md\":\"b0f63195\",\"program_frontend_node_chapter1_46.获取请求体.md\":\"fe989a69\",\"program_frontend_node_chapter2_index.md\":\"36c6085d\",\"program_frontend_node_chapter1_13.进程与线程.md\":\"33dd77e2\",\"暂存_english_单词_describe和explain.md\":\"bcd60b47\",\"program_frontend_vue_vue3_1.组合api_10.自定义hook函数.md\":\"675f477f\",\"program_frontend_webpack_chapter1_7.处理样式资源.md\":\"08d3067a\",\"program_frontend_node_chapter1_48.获取请求路径和查询字符串.md\":\"b6f87476\",\"program_frontend_webpack_chapter1_10.处理stylus和stylus资源.md\":\"af32e942\",\"program_frontend_node_chapter3_13.静态资源中间件注意事项.md\":\"8c27144e\",\"program_frontend_vue_vue3_1.组合api_3.reactive的基本使用.md\":\"f0e8c2f4\",\"program_frontend_node_chapter1_60.解决乱码问题.md\":\"84b5ebc6\",\"暂存_gitlab添加sshkey.md\":\"f6154aca\",\"program_frontend_typescript_inbox_一个ts项目怎么使用多个配置文件.md\":\"365f6e19\",\"暂存_storage封装.md\":\"360dc743\",\"program_frontend_typescript_inbox_projectreference.md\":\"3c4289ae\",\"program_frontend_node_chapter3_23.express中使用ejs.md\":\"056dfeaa\",\"program_frontend_node_chapter1_51.http练习.md\":\"c805812b\",\"program_frontend_vue_vue3_base_note_ref解包是什么意思.md\":\"6b5c12d4\",\"program_frontend_vue_vue3_base_officialdocument_深入组件_1.注册.md\":\"acdc1f0d\",\"program_frontend_webpack_chapter1_23.生产模式.md\":\"6d204f75\",\"暂存_node_node历史.md\":\"3faf2cc9\",\"program_frontend_webpack_index.md\":\"843cc0f9\",\"program_frontend_node_chapter3_10.全局中间件练习.md\":\"256be9ff\",\"program_frontend_webpack_chapter2_33.oneof提升打包构建速度.md\":\"c17acc72\",\"program_frontend_node_chapter1_15.fs模块异步与同步.md\":\"580f550f\",\"暂存_导航网站_网站导航.md\":\"1d486d6a\",\"program_frontend_webpack_chapter1_25.css兼容性处理.md\":\"fd202bb6\",\"program_frontend_typescript_summary_类型的写法.md\":\"693fb37d\",\"thinkandrecord_命运.md\":\"de60b7c2\",\"program_frontend_node_chapter1_42.创建http服务.md\":\"24760a99\",\"program_frontend_webpack_chapter1_24.提取css成单独文件.md\":\"025efd89\",\"program_frontend_toolbox_dayjs_index.md\":\"f63ff39f\",\"program_interview_typescript_ts和js有什么区别.md\":\"8c96e064\",\"program_frontend_webpack_chapter1_20.babel使用.md\":\"f21e420c\",\"program_frontend_node_chapter1_61.完善静态资源错误处理.md\":\"f1e5197b\",\"program_frontend_webpack_chapter1_6.开发模式.md\":\"113f540f\",\"program_frontend_webpack_base_bin目录的作用.md\":\"59c82e1c\",\"program_frontend_webpack_chapter2_30.webpack高级介绍.md\":\"aa2513ac\",\"program_frontend_vue_vue3_4.补充_混入.md\":\"73fb6b2f\",\"program_frontend_vue_vue3_1.组合api_1.setup测试.md\":\"8327f10f\",\"program_frontend_webpack_chapter2_48.总结.md\":\"7f51b781\",\"program_frontend_node_chapter3_5.获取路由参数.md\":\"cde6854e\",\"program_frontend_vue_vue3_2.新组件_3.suspense.md\":\"5e52b4aa\",\"program_frontend_uniapp_apk加固.md\":\"acadb27a\",\"program_frontend_webpack_chapter2_46.core-js.md\":\"872ecb63\",\"program_frontend_node_chapter5_1.mongodb介绍.md\":\"d60337ce\",\"program_frontend_node_chapter1_63.模块化介绍.md\":\"40b2ffd9\",\"program_frontend_vue_vue3_base_officialdocument_base_3.响应式基础.md\":\"376aa658\",\"program_frontend_node_chapter5_10.mongoose删除文档.md\":\"fee57b2c\",\"暂存_ts封装axios.md\":\"c210ad10\",\"program_frontend_node_chapter1_23.文件重命名和移动.md\":\"bc4f1f3f\",\"program_frontend_vue_vue3_1.组合api_4.目标对象和代理对象对比.md\":\"b3d1555e\",\"program_backend_index.md\":\"87531d5a\",\"program_frontend_vue_vue3_base_officialdocument_index.md\":\"e53a642d\",\"program_frontend_vue_vue3_1.组合api_9.vue2和vue3生命周期对比.md\":\"14e87139\",\"thinkandrecord_utils_怎么样把一件事坚持下去.md\":\"6f91dbc0\",\"thinkandrecord_学习方法.md\":\"d7b5aee2\",\"program_frontend_node_chapter5_4.数据库与集合命令.md\":\"9996f74f\",\"program_frontend_node_chapter1_22.练习文件复制.md\":\"5be71871\",\"thinkandrecord_work_学习的大方向.md\":\"7d23271c\",\"program_frontend_node_chapter1_25.文件夹操作.md\":\"856572f9\",\"program_frontend_javascript_构造函数.md\":\"56a18d2d\",\"program_frontend_node_chapter3_15.获取请求体数据.md\":\"83fe0113\",\"program_frontend_vue_vue3_base_officialdocument_base_13.组件基础.md\":\"6d448bfa\",\"program_frontend_node_chapter1_49.http练习.md\":\"9a695bef\",\"program_frontend_node_chapter1_40.ip的分类.md\":\"cce4e52f\",\"program_frontend_node_chapter5_8.mongoose字段类型.md\":\"bd727f50\",\"program_frontend_node_chapter1_65.模块暴露数据.md\":\"71bba9f6\",\"program_frontend_webpack_chapter1_18.eslint使用.md\":\"678e8f0a\",\"program_frontend_node_chapter1_31.__pathname和__dirname.md\":\"54d864a4\",\"program_frontend_node_chapter1_26.查看资源状态.md\":\"25acc9b5\",\"program_frontend_node_chapter1_29.文件批量重命名.md\":\"92d194fe\",\"program_frontend_webpack_chapter2_39.imageminimizer压缩图片.md\":\"506e1946\",\"program_base_index.md\":\"ef65e169\",\"program_frontend_node_chapter3_7.响应设置.md\":\"b481d629\",\"program_frontend_vue_vue3_1.组合api_18.customref.md\":\"614dbea4\",\"program_frontend_typescript_inbox_index.md\":\"c752b6d9\",\"program_frontend_webpack_chapter1_21.处理html资源.md\":\"2be5806b\",\"program_frontend_node_chapter1_50.设置http响应报文.md\":\"090ba1fb\",\"program_frontend_vue_vue3_base_officialdocument_base_8.事件监听.md\":\"24f5e5a6\",\"program_frontend_node_chapter5_7.mongoose插入文档.md\":\"d1e321f1\",\"resource_index.md\":\"ad07b59d\",\"暂存_图解ssh原理_图解ssh原理.md\":\"262500db\",\"program_frontend_webpack_chapter2_40.codesplit优化代码运行性能.md\":\"a20141ca\",\"program_frontend_webpack_chapter2_41.单入口优化代码运行性能.md\":\"08f3a4cf\",\"program_frontend_node_chapter3_25.查看文件上传报文.md\":\"0109624b\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"VitePress\",\"description\":\"Just playing around.\",\"base\":\"/\",\"head\":[],\"appearance\":true,\"themeConfig\":{\"nav\":[{\"text\":\"计算机科学\",\"link\":\"/computerscience/\"},{\"text\":\"编程\",\"link\":\"/program/\"},{\"text\":\"待办事项\",\"link\":\"/todolist/\"}]},\"locales\":{},\"scrollOffset\":90,\"cleanUrls\":false}");</script>
    
  </body>
</html>