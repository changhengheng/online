import{_ as e,o,c as s,Q as a}from"./chunks/framework.19358895.js";const q=JSON.parse('{"title":"引入模块数据","description":"","frontmatter":{},"headers":[],"relativePath":"program/frontend/Node/chapter1/66.引入模块数据.md","filePath":"program/frontend/Node/chapter1/66.引入模块数据.md","lastUpdated":1697287289000}'),p={name:"program/frontend/Node/chapter1/66.引入模块数据.md"},l=a('<h1 id="引入模块数据" tabindex="-1">引入模块数据 <a class="header-anchor" href="#引入模块数据" aria-label="Permalink to &quot;引入模块数据&quot;">​</a></h1><p>在模块中使用 require 传入文件路径即可引入文件 ：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">obj</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">require</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;./test&quot;</span><span style="color:#E1E4E8;">);</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">obj</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">require</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;./test&quot;</span><span style="color:#24292E;">);</span></span></code></pre></div><p>require 使用的一些注意事项：</p><ul><li><p>对于自己创建的模块，导入时路径建议写相对路径 ，且不能省略 <code>./</code> 和 <code>../</code></p><ul><li>require 使用相对路径不受工作目录的影响，这是和 fs 模块不同的地方</li><li>相对路径比较简单</li><li>项目中都会使用相对路径</li></ul></li><li><p>js 和 json 文件导入时可以不用写后缀，c/c++编写的 node 扩展文件也可以不写后缀，但是一般用不到</p><p>如果js和json文件同名，导入时如果省略后缀，会先导入js文件，再导入json文件</p></li><li><p>如果导入其他类型的文件，会以 js 文件进行处理</p></li><li><p>如果导入的路径是个文件夹，则会首先检测该文件夹下 <code>package.json</code> 文件中 <code>main</code> 属性对应的文件是否存在</p><p>如果存在则导入，反之如果文件不存在会报错。</p><p>如果 <code>main</code> 属性不存在，或者 <code>package.json</code> 不存在，则会尝试导入文件夹下的 <code>index.js</code> 和 <code>index.json</code>， 如果还是没找到，就会报错</p><blockquote><p>包管理工具导的就是文件夹</p></blockquote></li><li><p>导入 node.js 内置模块时，直接 require 模块的名字即可，无需加 <code>./</code> 和 <code>../</code></p></li></ul><h2 id="require和fs中的相对路径" tabindex="-1">require和fs中的相对路径 <a class="header-anchor" href="#require和fs中的相对路径" aria-label="Permalink to &quot;require和fs中的相对路径&quot;">​</a></h2><p>require的工作原理：</p><ul><li>看该模块是不是node内置的模块</li><li>看该模块是不是在node-modules中</li><li>如果是相对路径，是以当前所编辑文件所在的位置为基准，去require该模块</li><li>一般不用绝对路径，因为我们没办法知道服务器的绝对路径。</li></ul><p>fs读取文件时，路径是根据pwd路径（目前所在的工作目录的绝对路径）来的，相当于在控制台执行node时的路径，并不是根据写fs的文件本身去定位的。</p><blockquote><p>即，fs模块和require使用相对路径时，参考的对象是不一样的，fs参考执行node命令时终端所在的路径，require参考当前文件所在的路径</p></blockquote><p>解决方案：使用fs时，若想以当前文件为路径基准，就可以加上path.join(__dirName, 相对于当前文件的路径），即可。就可以以当前文件为基准，找到绝对路径下的文件。</p>',11),n=[l];function r(t,c,i,d,u,_){return o(),s("div",null,n)}const f=e(p,[["render",r]]);export{q as __pageData,f as default};
