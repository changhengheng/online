import{_ as s,o as a,c as n,Q as o}from"./chunks/framework.419948d5.js";const l="/assets/2599999-45f94d4ffd4bd903.4cadf7e5.jpeg",e="/assets/2599999-ae457963c1c8d11c.8f8b93a3.jpeg",p="/assets/2599999-84a29202134639ee.bbdcd119.jpeg",t="/assets/2599999-24ee000b10a917cf.d34c71b4.jpeg",r="/assets/2599999-da9359eb5fe05c32.56e6f57f.jpeg",c="/assets/2599999-c405729b13b0495d.d57c3309.jpeg",i="/assets/2599999-c99f4ec212b29d4d.0a68eda1.jpeg",y="/assets/2599999-75be0b7dca240ad8.fa396b63.jpeg",h="/assets/2599999-b74d757831e923ad.7849ccc6.jpeg",A=JSON.parse('{"title":"图解SSH原理","description":"","frontmatter":{"tags":"转载"},"headers":[],"relativePath":"暂存/图解SSH原理/图解SSH原理.md","filePath":"暂存/图解SSH原理/图解SSH原理.md","lastUpdated":1693990729000}'),E={name:"暂存/图解SSH原理/图解SSH原理.md"},d=o('<p><a href="https://www.jianshu.com/p/33461b619d53" target="_blank" rel="noreferrer">原文链接</a></p><h1 id="图解ssh原理" tabindex="-1">图解SSH原理 <a class="header-anchor" href="#图解ssh原理" aria-label="Permalink to &quot;图解SSH原理&quot;">​</a></h1><p><img src="'+l+'" alt="img"></p><p>主要内容</p><h2 id="_1-初见ssh" tabindex="-1">1. 初见SSH <a class="header-anchor" href="#_1-初见ssh" aria-label="Permalink to &quot;1. 初见SSH&quot;">​</a></h2><p><a href="http://www.ietf.org/rfc/rfc4251.txt" target="_blank" rel="noreferrer">SSH</a>是一种协议标准，其目的是实现<strong>安全远程登录</strong>以及其它<strong>安全网络服务</strong>。</p><blockquote><p>SSH仅仅是一<strong>协议标准</strong>，其具体的实现有很多，既有开源实现的OpenSSH，也有商业实现方案。使用范围最广泛的当然是开源实现OpenSSH。</p></blockquote><h2 id="_2-ssh工作原理" tabindex="-1">2. SSH工作原理 <a class="header-anchor" href="#_2-ssh工作原理" aria-label="Permalink to &quot;2. SSH工作原理&quot;">​</a></h2><p>在讨论SSH的原理和使用前，我们需要分析一个问题：<strong>为什么需要SSH？</strong></p><p>从1.1节SSH的定义中可以看出，SSH和telnet、ftp等协议主要的区别在于<strong>安全性</strong>。这就引出下一个问题：<strong>如何实现数据的安全呢？<strong>首先想到的实现方案肯定是对数据进行</strong>加密</strong>。加密的方式主要有两种：</p><ol><li>对称加密（也称为秘钥加密）</li><li>非对称加密（也称公钥加密）</li></ol><p>所谓对称加密，指加密解密使用同一套秘钥。如下图所示：</p><p><img src="'+e+'" alt="img"></p><p>图1-1：对称加密-Client端</p><p><img src="'+p+'" alt="img"></p><p>图1-2：对称加密-Server端</p><p>对称加密的加密强度高，很难破解。但是在实际应用过程中不得不面临一个棘手的问题：<strong>如何安全的保存密钥呢？<strong>尤其是考虑到数量庞大的Client端，很难保证密钥不被泄露。一旦一个Client端的密钥被窃据，那么整个系统的安全性也就不复存在。为了解决这个问题，<strong>非对称加密</strong>应运而生。非对称加密有两个密钥：</strong>“公钥”<strong>和</strong>“私钥”</strong>。</p><blockquote><p>两个密钥的特性：公钥加密后的密文，只能通过对应的私钥进行解密。而通过公钥推理出私钥的可能性微乎其微。</p></blockquote><p>下面看下使用非对称加密方案的登录流程：</p><p><img src="'+t+'" alt="img"></p><p>图1-3：非对称加密登录流程</p><ol><li>远程Server收到Client端用户TopGun的登录请求，Server把自己的公钥发给用户。</li><li>Client使用这个公钥，将密码进行加密。</li><li>Client将加密的密码发送给Server端。</li><li>远程Server用自己的私钥，解密登录密码，然后验证其合法性。</li><li>若验证结果，给Client相应的响应。</li></ol><blockquote><p>私钥是Server端独有，这就保证了Client的登录信息即使在网络传输过程中被窃据，也没有私钥进行解密，保证了数据的安全性，这充分利用了非对称加密的特性。</p></blockquote><h6 id="这样就一定安全了吗" tabindex="-1">这样就一定安全了吗？ <a class="header-anchor" href="#这样就一定安全了吗" aria-label="Permalink to &quot;这样就一定安全了吗？&quot;">​</a></h6><p>上述流程会有一个问题：<strong>Client端如何保证接受到的公钥就是目标Server端的？</strong>，如果一个攻击者中途拦截Client的登录请求，向其发送自己的公钥，Client端用攻击者的公钥进行数据加密。攻击者接收到加密信息后再用自己的私钥进行解密，不就窃取了Client的登录信息了吗？这就是所谓的<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noreferrer">中间人攻击</a></p><p><img src="'+r+`" alt="img"></p><p>图1-4：中间人攻击</p><h6 id="ssh中是如何解决这个问题的" tabindex="-1">SSH中是如何解决这个问题的？ <a class="header-anchor" href="#ssh中是如何解决这个问题的" aria-label="Permalink to &quot;SSH中是如何解决这个问题的？&quot;">​</a></h6><h5 id="_1-基于口令的认证" tabindex="-1">1. 基于口令的认证 <a class="header-anchor" href="#_1-基于口令的认证" aria-label="Permalink to &quot;1. 基于口令的认证&quot;">​</a></h5><p>从上面的描述可以看出，问题就在于<strong>如何对Server的公钥进行认证？<strong>在https中可以通过CA来进行公证，可是SSH的</strong>publish key</strong>和<strong>private key</strong>都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。通常在第一次登录的时候，系统会出现下面提示信息：</p><div class="language-rust vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">The</span><span style="color:#E1E4E8;"> authenticity of host &#39;</span><span style="color:#B392F0;">ssh</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">server</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">example</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;">com (</span><span style="color:#79B8FF;">12.18</span><span style="color:#F97583;">.</span><span style="color:#79B8FF;">429.21</span><span style="color:#E1E4E8;">)</span><span style="color:#9ECBFF;">&#39; can&#39;</span><span style="color:#E1E4E8;">t be established</span><span style="color:#F97583;">.</span></span>
<span class="line"><span style="color:#79B8FF;">RSA</span><span style="color:#E1E4E8;"> key fingerprint is </span><span style="color:#79B8FF;">98</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">2e</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">d7</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">e0</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">de</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">9f</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">ac</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">67</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">28</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">c2</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">42</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">2d</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">37</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">16</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;">58</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;">4d</span><span style="color:#F97583;">.</span></span>
<span class="line"><span style="color:#B392F0;">Are</span><span style="color:#E1E4E8;"> you sure you want to </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;"> connecting (yes</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">no)</span><span style="color:#F97583;">?</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">The</span><span style="color:#24292E;"> authenticity of host &#39;</span><span style="color:#6F42C1;">ssh</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">server</span><span style="color:#D73A49;">.</span><span style="color:#24292E;">example</span><span style="color:#D73A49;">.</span><span style="color:#24292E;">com (</span><span style="color:#005CC5;">12.18</span><span style="color:#D73A49;">.</span><span style="color:#005CC5;">429.21</span><span style="color:#24292E;">)</span><span style="color:#032F62;">&#39; can&#39;</span><span style="color:#24292E;">t be established</span><span style="color:#D73A49;">.</span></span>
<span class="line"><span style="color:#005CC5;">RSA</span><span style="color:#24292E;"> key fingerprint is </span><span style="color:#005CC5;">98</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">2e</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">d7</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">e0</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">de</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">9f</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">ac</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">67</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">28</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">c2</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">42</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">2d</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">37</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">16</span><span style="color:#D73A49;">:</span><span style="color:#005CC5;">58</span><span style="color:#D73A49;">:</span><span style="color:#24292E;">4d</span><span style="color:#D73A49;">.</span></span>
<span class="line"><span style="color:#6F42C1;">Are</span><span style="color:#24292E;"> you sure you want to </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;"> connecting (yes</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">no)</span><span style="color:#D73A49;">?</span></span></code></pre></div><p>上面的信息说的是：无法确认主机ssh-server.example.com（12.18.429.21）的真实性，不过知道它的公钥指纹，是否继续连接？</p><blockquote><p>之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。</p></blockquote><p>如果输入<strong>yes</strong>后，会出现下面信息：</p><div class="language-php vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">php</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#B392F0;">Warning</span><span style="color:#E1E4E8;">: </span><span style="color:#79B8FF;">Permanently</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">added</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;ssh-server.example.com,12.18.429.21&#39;</span><span style="color:#E1E4E8;"> (</span><span style="color:#79B8FF;">RSA</span><span style="color:#E1E4E8;">) </span><span style="color:#79B8FF;">to</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">the</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">list</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">of</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">known</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">hosts</span><span style="color:#F97583;">.</span><span style="color:#E1E4E8;"> </span></span>
<span class="line"><span style="color:#B392F0;">Password</span><span style="color:#E1E4E8;">: (</span><span style="color:#79B8FF;">enter</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">password</span><span style="color:#E1E4E8;">)</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6F42C1;">Warning</span><span style="color:#24292E;">: </span><span style="color:#005CC5;">Permanently</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">added</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;ssh-server.example.com,12.18.429.21&#39;</span><span style="color:#24292E;"> (</span><span style="color:#005CC5;">RSA</span><span style="color:#24292E;">) </span><span style="color:#005CC5;">to</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">the</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">list</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">of</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">known</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">hosts</span><span style="color:#D73A49;">.</span><span style="color:#24292E;"> </span></span>
<span class="line"><span style="color:#6F42C1;">Password</span><span style="color:#24292E;">: (</span><span style="color:#005CC5;">enter</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">password</span><span style="color:#24292E;">)</span></span></code></pre></div><p>该host已被确认，并被追加到文件<strong>known_hosts</strong>中，然后就需要输入密码，之后的流程就按照图1-3进行。</p><h5 id="_2-基于公钥认证" tabindex="-1">2.基于公钥认证 <a class="header-anchor" href="#_2-基于公钥认证" aria-label="Permalink to &quot;2.基于公钥认证&quot;">​</a></h5><p>在上面介绍的登录流程中可以发现，每次登录都需要输入密码，很麻烦。SSH提供了另外一种可以免去输入密码过程的登录方式：公钥登录。流程如下：</p><p><img src="`+c+'" alt="img"></p><p>图1-5：公钥认证流程(2018-06更新)</p><ol><li><s>Client端用户TopGun将自己的公钥存放在Server上，追加在文件authorized_keys中。</s></li><li><s>Server收到登录请求后，随机生成一个字符串str1，并发送给Client。</s></li><li><s>Client用自己的私钥对字符串str1进行加密。</s></li><li><s>将加密后字符串发送给Server。</s></li><li><s>Server用之前存储的公钥进行解密，比较解密后的str2和str1。</s></li><li><s>根据比较结果，返回客户端登陆结果。</s></li></ol><h2 id="上述流程有误-更正如下" tabindex="-1">上述流程有误，更正如下 <a class="header-anchor" href="#上述流程有误-更正如下" aria-label="Permalink to &quot;上述流程有误，更正如下&quot;">​</a></h2><ol><li>Client将自己的公钥存放在Server上，追加在文件authorized_keys中。</li><li>Server端接收到Client的连接请求后，会在authorized_keys中匹配到Client的公钥pubKey，并生成随机数R，用Client的公钥对该随机数进行加密得到pubKey(R) ，然后将加密后信息发送给Client。</li><li>Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。</li><li>Server端会也会对R和SessionKey利用同样摘要算法生成Digest2。</li><li>Server端会最后比较Digest1和Digest2是否相同，完成认证过程。</li></ol><blockquote><p>在步骤1中，Client将自己的公钥存放在Server上。需要用户手动将公钥copy到server上。这就是在配置ssh的时候进程进行的操作。下图是GitHub上SSH keys设置视图：</p><p><img src="'+i+`" alt="img"></p><p>GitHub中SSH keys设置</p></blockquote><h2 id="_3-ssh实践" tabindex="-1">3. SSH实践 <a class="header-anchor" href="#_3-ssh实践" aria-label="Permalink to &quot;3. SSH实践&quot;">​</a></h2><h6 id="生成密钥操作" tabindex="-1">生成密钥操作 <a class="header-anchor" href="#生成密钥操作" aria-label="Permalink to &quot;生成密钥操作&quot;">​</a></h6><p>经过上面的原理分析，下面三行命令的含义应该很容易理解了：</p><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">$ ssh</span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">keygen </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">t rsa </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">P</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">-</span><span style="color:#E1E4E8;">f </span><span style="color:#F97583;">~</span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">.ssh</span><span style="color:#9ECBFF;">/i</span><span style="color:#E1E4E8;">d_rsa</span></span>
<span class="line"><span style="color:#E1E4E8;">$ cat </span><span style="color:#F97583;">~</span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">.ssh</span><span style="color:#9ECBFF;">/i</span><span style="color:#E1E4E8;">d_rsa.pub </span><span style="color:#F97583;">&gt;&gt;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">~</span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">.ssh</span><span style="color:#9ECBFF;">/</span><span style="color:#E1E4E8;">authorized_keys</span></span>
<span class="line"><span style="color:#E1E4E8;">$ chmod </span><span style="color:#79B8FF;">0600</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">~</span><span style="color:#9ECBFF;">/</span><span style="color:#DBEDFF;">.ssh</span><span style="color:#9ECBFF;">/</span><span style="color:#E1E4E8;">authorized_keys</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">$ ssh</span><span style="color:#D73A49;">-</span><span style="color:#24292E;">keygen </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">t rsa </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">P</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&#39;&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">-</span><span style="color:#24292E;">f </span><span style="color:#D73A49;">~</span><span style="color:#032F62;">/.ssh/i</span><span style="color:#24292E;">d_rsa</span></span>
<span class="line"><span style="color:#24292E;">$ cat </span><span style="color:#D73A49;">~</span><span style="color:#032F62;">/.ssh/i</span><span style="color:#24292E;">d_rsa.pub </span><span style="color:#D73A49;">&gt;&gt;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">~</span><span style="color:#032F62;">/.ssh/</span><span style="color:#24292E;">authorized_keys</span></span>
<span class="line"><span style="color:#24292E;">$ chmod </span><span style="color:#005CC5;">0600</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">~</span><span style="color:#032F62;">/.ssh/</span><span style="color:#24292E;">authorized_keys</span></span></code></pre></div><p>ssh-keygen是用于生产密钥的工具。</p><ul><li>-t：指定生成密钥类型（rsa、dsa、ecdsa等）</li><li>-P：指定passphrase，用于确保私钥的安全</li><li>-f：指定存放密钥的文件（公钥文件默认和私钥同目录下，不同的是，存放公钥的文件名需要加上后缀.pub）</li></ul><p>首先看下面~/.ssh中的四个文件：</p><p><img src="`+y+'" alt="img"></p><p>SSH-涉及文件</p><ol><li>id_rsa：保存私钥</li><li>id_rsa.pub：保存公钥</li><li>authorized_keys：保存已授权的客户端公钥</li><li>known_hosts：保存已认证的远程主机ID（关于known_hosts详情，见文末更新内容）</li></ol><p>四个角色的关系如下图所示：</p><p><img src="'+h+`" alt="img"></p><p>SSH 结构简图</p><blockquote><p>需要注意的是：一台主机可能既是Client，也是Server。所以会同时拥有authorized_keys和known_hosts。</p></blockquote><h6 id="登录操作" tabindex="-1">登录操作 <a class="header-anchor" href="#登录操作" aria-label="Permalink to &quot;登录操作&quot;">​</a></h6><div class="language-ruby vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ruby</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;"># 以用户名user，登录远程主机host</span></span>
<span class="line"><span style="color:#E1E4E8;">$ ssh user@host</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 本地用户和远程用户相同，则用户名可省去</span></span>
<span class="line"><span style="color:#E1E4E8;">$ ssh host</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># SSH默认端口22，可以用参数p修改端口</span></span>
<span class="line"><span style="color:#E1E4E8;">$ ssh </span><span style="color:#F97583;">-</span><span style="color:#79B8FF;">p</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">2017</span><span style="color:#E1E4E8;"> user@host</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;"># 以用户名user，登录远程主机host</span></span>
<span class="line"><span style="color:#24292E;">$ ssh user@host</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># 本地用户和远程用户相同，则用户名可省去</span></span>
<span class="line"><span style="color:#24292E;">$ ssh host</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D;"># SSH默认端口22，可以用参数p修改端口</span></span>
<span class="line"><span style="color:#24292E;">$ ssh </span><span style="color:#D73A49;">-</span><span style="color:#005CC5;">p</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">2017</span><span style="color:#24292E;"> user@host</span></span></code></pre></div><h3 id="_4-总结" tabindex="-1">4 总结 <a class="header-anchor" href="#_4-总结" aria-label="Permalink to &quot;4 总结&quot;">​</a></h3><p>本文以图文方式对SSH原理进行解析（主要指远程登录，没有涉及端口转发等功能）。同时分析了非对称加密的特性，以及在实践过程中如何对加密操作进行改进。</p><h3 id="_5-持续更新" tabindex="-1">5.========== 持续更新 ========== <a class="header-anchor" href="#_5-持续更新" aria-label="Permalink to &quot;5.========== 持续更新 ==========&quot;">​</a></h3><ol><li>感谢@<a href="https://www.jianshu.com/u/aee807abde90" target="_blank" rel="noreferrer">李白走天涯</a>、<a href="https://www.jianshu.com/u/d83ea74c528b" target="_blank" rel="noreferrer">Dargonfly429</a>的指正，图1.5中认证流程有误，下面是更正后的流程：</li></ol><blockquote><p>Server端在authorized_keys中匹配到Client的公钥后，会生成随机数R，并用<strong>Client的公钥对该随机数进行加密</strong>，然后将加密后信息发送给Client，Client端通过私钥进行解密得到随机数R，然后对随机数R和本次会话的SessionKey利用MD5生成摘要Digest1，发送给Server端。Server端会也会对R和SessionKey利用同样摘要算法生成Digest2，最后比较Digest1和Digest2是否相同，完成认证过程。</p></blockquote><ol><li>感谢 <a href="https://www.jianshu.com/u/3335b8c6d402" target="_blank" rel="noreferrer">Michael2397</a>评论，Client端的public key是Client手动Copy到Server端的，SSH建立连接过程中没有公钥的交换操作。另外图1.5还需要添加一点，Server端根据什么信息在authorized_keys中进行查找的呢？主要是根据Client在认证的开始会发送一个KeyID给Server，这个KeyID会唯一对应该Client的一个PublicKey，Server就是通过该KeyID在authorized_keys进行查找对应的PublicKey。</li></ol><h3 id="_2018-08-02-更新" tabindex="-1">===========2018-08-02 更新================ <a class="header-anchor" href="#_2018-08-02-更新" aria-label="Permalink to &quot;===========2018-08-02 更新================&quot;">​</a></h3><p>感谢@<a href="https://www.jianshu.com/u/544d66f8c38a" target="_blank" rel="noreferrer">风笑天2013</a>指正，下面关于SSH的<strong>known_hosts</strong>机制做如下更正：</p><h5 id="_1-known-hosts中存储的内容是什么" tabindex="-1">1. known_hosts中存储的内容是什么？ <a class="header-anchor" href="#_1-known-hosts中存储的内容是什么" aria-label="Permalink to &quot;1. known_hosts中存储的内容是什么？&quot;">​</a></h5><p>known_hosts中存储是已认证的远程主机host key，每个SSH Server都有一个<strong>secret, unique ID, called a host key</strong>。</p><h5 id="_2-host-key何时加入known-hosts的" tabindex="-1">2. host key何时加入known_hosts的？ <a class="header-anchor" href="#_2-host-key何时加入known-hosts的" aria-label="Permalink to &quot;2. host key何时加入known_hosts的？&quot;">​</a></h5><p>当我们第一次通过SSH登录远程主机的时候，Client端会有如下提示：</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">Host key not found from the list of known hosts.</span></span>
<span class="line"><span style="color:#E1E4E8;">Are you sure you want to </span><span style="color:#F97583;">continue</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">connecting</span><span style="color:#E1E4E8;"> (yes</span><span style="color:#F97583;">/</span><span style="color:#E1E4E8;">no)</span><span style="color:#F97583;">?</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">Host key not found from the list of known hosts.</span></span>
<span class="line"><span style="color:#24292E;">Are you sure you want to </span><span style="color:#D73A49;">continue</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">connecting</span><span style="color:#24292E;"> (yes</span><span style="color:#D73A49;">/</span><span style="color:#24292E;">no)</span><span style="color:#D73A49;">?</span></span></code></pre></div><p>此时，如果我们选择<strong>yes</strong>，那么该host key就会被加入到Client的known_hosts中，格式如下：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;"># domain name</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">encryption algorithm</span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;">host key</span></span>
<span class="line"><span style="color:#E1E4E8;">example</span><span style="color:#B392F0;">.hostname.com</span><span style="color:#E1E4E8;"> </span><span style="color:#85E89D;">ssh-rsa</span><span style="color:#E1E4E8;"> AAAAB4NzaC1yc2EAAAABIwAAAQEA。。。</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;"># domain name</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">encryption algorithm</span><span style="color:#D73A49;">+</span><span style="color:#24292E;">host key</span></span>
<span class="line"><span style="color:#24292E;">example</span><span style="color:#6F42C1;">.hostname.com</span><span style="color:#24292E;"> </span><span style="color:#22863A;">ssh-rsa</span><span style="color:#24292E;"> AAAAB4NzaC1yc2EAAAABIwAAAQEA。。。</span></span></code></pre></div><h5 id="_3-为什么需要known-hosts" tabindex="-1">3. 为什么需要known_hosts？ <a class="header-anchor" href="#_3-为什么需要known-hosts" aria-label="Permalink to &quot;3. 为什么需要known_hosts？&quot;">​</a></h5><p>最后探讨下为什么需要known_hosts，这个文件主要是通过Client和Server的双向认证，从而避免中间人（<strong>man-in-the-middle attack</strong>）攻击，每次Client向Server发起连接的时候，不仅仅Server要验证Client的合法性，Client同样也需要验证Server的身份，SSH client就是通过known_hosts中的host key来验证Server的身份的。</p><blockquote><p>这中方案足够安全吗？当然不，比如第一次连接一个未知Server的时候，known_hosts还没有该Server的host key，这不也可能遭到<strong>中间人</strong>攻击吗？这可能只是安全性和可操作性之间的折中吧。</p></blockquote><p>灰常感谢大家，希望收到更多的评论指正。</p>`,79),u=[d];function g(F,k,S,C,b,_){return a(),n("div",null,u)}const v=s(E,[["render",g]]);export{A as __pageData,v as default};
