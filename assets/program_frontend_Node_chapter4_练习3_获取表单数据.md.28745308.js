import{_ as e,o,c as t,Q as r}from"./chunks/framework.19358895.js";const m=JSON.parse('{"title":"获取表单数据","description":"","frontmatter":{},"headers":[],"relativePath":"program/frontend/Node/chapter4/练习3_获取表单数据.md","filePath":"program/frontend/Node/chapter4/练习3_获取表单数据.md","lastUpdated":1697452647000}'),n={name:"program/frontend/Node/chapter4/练习3_获取表单数据.md"},a=r('<h1 id="获取表单数据" tabindex="-1">获取表单数据 <a class="header-anchor" href="#获取表单数据" aria-label="Permalink to &quot;获取表单数据&quot;">​</a></h1><p>表单想要把数据传递给服务端，每一个表单项都必须保证有name值，服务端会使用该name值获取对应表单项的值；且表单需要设置method和action属性，method是请求方式，action是请求的服务器地址。</p><p>action 的请求地址应该写成省略协议、域名和端口的相对路径，即使之后域名或端口更换，也能找到对应的服务器地址，更加灵活</p><h2 id="express-json-options" tabindex="-1">express.json([options]) <a class="header-anchor" href="#express-json-options" aria-label="Permalink to &quot;express.json([options])&quot;">​</a></h2><p>Express 内置的中间件函数，返回一个中间件。</p><p>用于查看 Content-Type 标头与 type 选项（默认&quot;application/json&quot;）匹配的请求，并解析该请求的 <strong>JSON 格式</strong>的请求体数据。</p><p>包含解析数据的 body 对象会填充到 request 对象上（等同于body-parser 的 req.body）</p><p>如果 Content-Type 不匹配则填充一个空对象 <code>{}</code></p><h2 id="express-urlencoded-options" tabindex="-1">express.urlencoded([options]) <a class="header-anchor" href="#express-urlencoded-options" aria-label="Permalink to &quot;express.urlencoded([options])&quot;">​</a></h2><p>Express 内置的中间件函数，返回一个中间件。</p><p>用于查看 Content-Type 标头与 type 选项（默认&quot;&quot;application/x-www-form-urlencoded&quot;&quot;）匹配的请求，并解析该请求的 <strong>URL-encoded 格式</strong>的请求体数据</p><p>如果 Content-Type 不匹配则填充一个空对象 <code>{}</code></p><p>由于 req.body 的数据基于用户控制的输入，因此该对象中的所有属性和值都是不可信的，应该在信任之前进行验证。 例如，req.body.foo.toString() 可能以多种方式失败，例如 foo 可能不存在或可能不是字符串，toString 可能不是函数，而是字符串或其他用户输入。</p>',13),p=[a];function s(d,c,i,_,l,h){return o(),t("div",null,p)}const f=e(n,[["render",s]]);export{m as __pageData,f as default};
