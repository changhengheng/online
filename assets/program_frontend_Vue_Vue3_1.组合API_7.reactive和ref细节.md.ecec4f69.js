import{_ as r,o as t,c as a,k as e,a as l}from"./chunks/framework.419948d5.js";const h=JSON.parse('{"title":"reactive 和 ref 细节","description":"","frontmatter":{},"headers":[],"relativePath":"program/frontend/Vue/Vue3/1.组合API/7.reactive和ref细节.md","filePath":"program/frontend/Vue/Vue3/1.组合API/7.reactive和ref细节.md","lastUpdated":1694412824000}'),i={name:"program/frontend/Vue/Vue3/1.组合API/7.reactive和ref细节.md"},o=e("h1",{id:"reactive-和-ref-细节",tabindex:"-1"},[l("reactive 和 ref 细节 "),e("a",{class:"header-anchor",href:"#reactive-和-ref-细节","aria-label":'Permalink to "reactive 和 ref 细节"'},"​")],-1),c=e("ul",null,[e("li",null,"是 Vue3 的 composition API 中 2 个最重要的响应式 API"),e("li",null,"ref 用来处理基本类型数据， reactive 用来处理对象(递归深度响应式)"),e("li",null,"如果用 ref 对象/数组， 内部会自动将对象/数组转换为 reactive 的代理对象（.value 拿到 reactive 的 Proxy 对象）"),e("li",null,"ref 内部: 通过给 value 属性添加 getter/setter 来实现对数据的劫持"),e("li",null,"reactive 内部: 通过使用 Proxy 来实现对对象内部所有数据的劫持， 并通过 Reflect 操作对象内部数据"),e("li",null,"ref 的数据操作: 在 js 中要.value， 在模板中不需要(内部解析模板时会自动添加.value)"),e("li",null,"代理对象新增和删除属性的操作也会触发视图更新")],-1),n=[o,c];function s(f,u,d,_,v,p){return t(),a("div",null,n)}const P=r(i,[["render",s]]);export{h as __pageData,P as default};
