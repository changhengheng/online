# 计算属性

问题：模板中的表达式虽然方便，但也只能用来做简单的操作。如果在模板中写太多逻辑，会让模板变得臃肿，难以维护。

解决：计算属性用来描述依赖响应式状态的复杂逻辑。

用法：computed() 方法接收一个 getter 函数，返回值为一个 计算属性 ref 对象。

注意：

- 计算属性 ref 对象 也会在模板中自动解包，因此在模板表达式中引用时无需添加 .value。
- Vue 的计算属性会自动追踪响应式依赖。即，当计算属性 ref 对象的响应式依赖改变时，任何依赖于 计算属性 ref 对象 的绑定都会同时更新。而非响应式依赖，比如 Date.now()，虽然每次执行时几乎都会发生改变，但不会被自动追踪。

> 常见的声明响应式状态的方法：ref()、reactive()，常见的响应式状态数据：Ref 对象、proxy 代理对象
> 普通数据不是响应式的

## 计算属性缓存 vs 方法

在模板中使用文本插值语法调用一个方法可以获得和计算属性相同的结果，但不同之处在于计算属性值会基于其响应式依赖被缓存。

一个计算属性仅会在其响应式依赖更新时才重新计算。这意味着，只要计算属性的响应式依赖没有发生改变，无论访问多少次计算属性都会立即返回之前的计算结果，而不用重复执行 getter 函数。

相比之下，方法调用总是会在重渲染发生时再次执行函数。

## 可写计算属性

计算属性默认是只读的。当你尝试修改一个计算属性时，你会收到一个运行时警告。只在某些特殊场景中你可能才需要用到“可写”的属性，你可以通过同时提供 getter 和 setter 来创建。

```js
<script setup>
import { ref, computed } from 'vue'

const firstName = ref('John')
const lastName = ref('Doe')

const fullName = computed({
  // getter
  get() {
    return firstName.value + ' ' + lastName.value
  },
  // setter
  set(newValue) {
    // 注意：我们这里使用的是解构赋值语法
    [firstName.value, lastName.value] = newValue.split(' ')
  }
})
</script>
```

## 最佳实践

- Getter 不应有副作用 ​
  计算属性的 getter 应只做计算而没有任何其他的副作用，这一点非常重要，请务必牢记。举例来说，不要在 getter 中做异步请求或者更改 DOM！一个计算属性的声明中描述的是如何根据其他值派生一个值。因此 getter 的职责应该仅为计算和返回该值。在之后的指引中我们会讨论如何使用侦听器根据其他响应式状态的变更来创建副作用。

- 避免直接修改计算属性值 ​
  从计算属性返回的值是派生状态。可以把它看作是一个“临时快照”，每当源状态发生变化时，就会创建一个新的快照。更改快照是没有意义的，因此计算属性的返回值应该被视为只读的，并且永远不应该被更改——应该更新它所依赖的源状态以触发新的计算。
