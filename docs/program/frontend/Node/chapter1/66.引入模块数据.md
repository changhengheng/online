# 引入模块数据

在模块中使用 require 传入文件路径即可引入文件 ：

```js
const obj = require("./test");
```

require 使用的一些注意事项： 

- 对于自己创建的模块，导入时路径建议写相对路径 ，且不能省略 `./` 和 `../`

  - require 使用相对路径不受工作目录的影响，这是和 fs 模块不同的地方
  - 相对路径比较简单
  - 项目中都会使用相对路径 

- js 和 json 文件导入时可以不用写后缀，c/c++编写的 node 扩展文件也可以不写后缀，但是一般用不到

  如果js和json文件同名，导入时如果省略后缀，会先导入js文件，再导入json文件

- 如果导入其他类型的文件，会以 js 文件进行处理

- 如果导入的路径是个文件夹，则会首先检测该文件夹下 `package.json` 文件中 `main` 属性对应的文件是否存在

  如果存在则导入，反之如果文件不存在会报错。 

  如果 `main` 属性不存在，或者 `package.json` 不存在，则会尝试导入文件夹下的 `index.js` 和 `index.json`， 如果还是没找到，就会报错

  > 包管理工具导的就是文件夹

- 导入 node.js 内置模块时，直接 require 模块的名字即可，无需加 `./` 和 `../`

## require和fs中的相对路径

require的工作原理：

- 看该模块是不是node内置的模块
- 看该模块是不是在node-modules中
- 如果是相对路径，是以当前所编辑文件所在的位置为基准，去require该模块
- 一般不用绝对路径，因为我们没办法知道服务器的绝对路径。

fs读取文件时，路径是根据pwd路径（目前所在的工作目录的绝对路径）来的，相当于在控制台执行node时的路径，并不是根据写fs的文件本身去定位的。

> 即，fs模块和require使用相对路径时，参考的对象是不一样的，fs参考执行node命令时终端所在的路径，require参考当前文件所在的路径

解决方案：使用fs时，若想以当前文件为路径基准，就可以加上path.join(__dirName, 相对于当前文件的路径），即可。就可以以当前文件为基准，找到绝对路径下的文件。